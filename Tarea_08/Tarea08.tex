\documentclass{article}

% Symbols
%\usepackage{recycle}
\usepackage{amsfonts, amsthm}
\usepackage{upgreek}
\usepackage{physics}
\usepackage{cancel}
\usepackage{amssymb, latexsym, amsmath}

%Algorithms
\usepackage[ruled,lined,linesnumbered,commentsnumbered]{algorithm2e}

%% Identación
\setlength{\parindent}{0cm}

% Código
\newcommand{\code}[1]{\textcolor{white!25!black}{\texttt{#1}}}
\usepackage{listings}

%AMS
\usepackage{amsthm}
\newtheorem{algo-thm}{Algoritmo}

% Proof
\renewcommand*{\proofname}{\textbf{Demostraci\'on:}}
% Theorem
\newtheorem*{theorem}{Teorema}

% Graphics
\usepackage{graphicx}
\usepackage{pgf}

% Color a letras.
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Tikz
\usepackage{tkz-graph}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
%\usetikzlibrary[topaths]

% Def. Dr. César.
\usetikzlibrary{shapes,calc}
\tikzstyle{edge}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.1pt]
\tikzstyle{blueE}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.5pt, blue]
\tikzstyle{blackV}=[circle, fill=black, minimum size=6pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{blueV}=[circle, fill=blue, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redV}=[circle, fill=red, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redSV}=[semicircle, fill=red, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blueSV}=[semicircle, fill=blue, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blackSV}=[semicircle, fill=black, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{vertex}=[circle, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]

% Margins
\addtolength{\voffset}{-1.5cm}
\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\textheight}{3cm}

%Header-Footer
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{1pt}

\newcommand{\set}[1]{
  \left\{ #1 \right\}
}

%\pagenumbering{gobble} -- Este comando
%                       -- quita el número de página.
\footskip = 50pt
\renewcommand{\headrulewidth}{1pt}

\pagestyle{fancyplain}

\begin{document}
\title{UNIVERSIDAD AUT\'ONOMA DE M\'EXICO\\ Facultad de Ciencias}
\author{Autores:
  \\ Fernanda Villaf\'an Flores
  \\ Fernando Alvarado Palacios
  \\ Adri\'an Aguilera Moreno}
\date{}
\maketitle
\begin{center}
  \includegraphics[scale=0.20]{../Imagen/Portada.jpg}\\[0.4cm]
  \Large
  \bf{Gr\'aficas y Juegos}
  \normalsize
\end{center}
\newpage
\fancyhead[r]{ Gr\'aficas y Juegos 2022-1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\LARGE{Tarea 8}}
\begin{enumerate}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 01
\item Sean $G$ una gr\'afica conexa y $e \in E$.   Demuestre que
  \begin{enumerate}
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ inciso (a)
  \item $e$ est\'a en cada \'arbol generador de $G$ si y s\'olo si $e$ es un puente
    de $G$;
        %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ inciso (b)
  \item $e$ no est\'a en \'arbol generador alguno de $G$ si y s\'olo si $e$ es un lazo.
  \end{enumerate}
  
  \newpage
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 02
\item Modifique el algoritmo BFS para que regrese una bipartici\'on de la
  gr\'afica (si la gr\'afica es bipartita) o un ciclo impar (si la gr\'afica no es bipartita).
  
  \textbf{\textit{Soluci\'on:}} Para este ejercicio, emplearemos las siguientes estructuras
  de datos:
  \begin{itemize}
  \item[$\cdot$)] Colas: Estas fungen de la misma manera que originalmente en \textbf{BFS}.
  \item[$\cdot$)] Listas: Estas nos servir\'an para insertas listas binarias en un tiempo
    constante en una posici\'on conocida.
  \item[$\cdot$)] Conjuntos: Esta estructura realmente se puede cambiar por una lista,
    arreglo (o la estructura que m\'as les guste), sin embargo, se emplean conjuntos
    para preservar, en la medida de lo posible, el concepto de parte de una bipartici\'on
    y aun m\'as porque, en este caso, necesitamos una bipartici\'on de v\'ertices.
  \end{itemize}
  
  \begin{center}
    \fbox{
      \begin{minipage}[b][1\height]%
        [t]{0.867\textwidth}
        Los ciclos de longitud impar son obstrucci\'on m\'inima de las gr\'aficas
        bipartitas. Este resultado se menciona en las notas de clase, adem\'as, esto
        se sigue por la caracterizaci\'on de gr\'aficas bipartitas (demostrado en
        clases), esto es,
        
        \begin{theorem}
          Sea $G$ una gr\'afica. Son equivalentes:
          \begin{enumerate}
          \item $G$ es bipartita.
          \item $G$ no contiene ciclos impares.
          \item $G$ no contiene ciclos impares inducidos.
          \end{enumerate}
          
        \end{theorem}
    \end{minipage}}
  \end{center}
  En esta ocasi\'on, empecemos mostrando que el algoritmo termina.
  Para esto s\'olo nos debemos fijar en el \underline{While} de  la
  l\'inea $25$\footnote{El an\'alisis del resto del algoritmo se
    realizo en clase y las modificaciones incluidas no alteran las
    condiciones iniciales de \textbf{BFS}.}. N\'otese que $x$ e $y$
  no son el nodo  ra\'iz, as\'i $x$ e $y$ son descendientes de $r$,
  por lo que ocasionalmente $\mathcal{P}(\mathcal{P}(\dotsm\mathcal{P}
  (x))) = r = \mathcal{P}(\mathcal{P}(\dotsm\mathcal{P}(y)))$\footnote{En
    otro caso, $x$ e $y$ tienen un ancestro comu\'un distinto de $r$
    y se cumple la misma condici\'on.}, como la cantidad de v\'ertices
  en $G$ es finita, entonces lo anterior pasa en una cantidad finita
  de iteraciones, por tanto la instrucci\'on iterativa de la l\'inea
  $25$ termina.
  
  Ahora, analicemos la complejidad del algoritmo. Sabemos que \textbf{BFS}
  tiene complejidad contenida en $\mathcal{O}(|E| + |V|)$, por tanto el
  algoritmo \code{OddCycleOrBipartition} tiene complejidad en $\mathcal{O}
  (|E|\cdot|V| + |V|^2) \approx \mathcal{O}(|V|^2)$, esto por la anexi\'on
  de la instrucci\'on iterativa \underline{While} de la l\'inea $25$, pues
  todas las dem\'as alteraciones a \textbf{BFS} se realizan en un tiempo constante.
  
  Para terminar de mostrar la correctez del algoritmo sólo falta ver que
  realmente hace lo que se pide, as\'i propongamos dos invariantes de ciclo:
  
  \textbf{Prop. 1:} [Invariante de ciclo, caso bipartita]. El conjunto
  devuelto por el algoritmo \code{OddCycleOrBipartition}, cuando $G$
  no contenga ciclos impares, es una bipartici\'on de $V_G$.  
  
  \textbf{Dem.}   Para esto veamos que:
  \begin{itemize}
  \item[$\cdot$)] $X\cup Y = V_G$. Por la l\'inea $5$, tenemos que el
    v\'ertice ra\'iz (que es el primero en entrar a la cola) se pinta
    de negro, por tanto sus hijos tienen un padre coloreado (y en concecuencia,
    estos ser\'an coloreados de blanco), luego por el \code{IF/ELSE}
    de la l\'inea $12$, el resto de los v\'ertices se pintan de negro
    o blanco, como todo el resto de v\'ertices es descendiente de $r$,
    entonces todos estos tienen un padre coloreado, pues su ancestro
    inmediato (no necesariamente $r$) est\'a coloreado. Luego, todos
    los v\'ertices de $G$ son coloreados (esto por la demostraci\'on de
    \textbf{BFS}) e introducidos en $X$ o $Y$, as\'i $X\cup Y = V_G$.
    
  \item[$\cdot$)] $X\cap Y = \emptyset$. Observemos que $r$ es coloreado
    de negro, as\'i los hijos de $r$ son coloreados de blanco. Luego,
    para alg\'un v\'ertice $x$ distinto de $r$ se tiene que si $x$ est\'a
    coloreado de negro, entonces sus hijos ser\'an coloreados de blanco
    (an\'alogo el caso cuando $x$ es de color blanco). Si suponemos que
    existe un $z \in V_G : z \in X \land z \in Y$, entonces $z$ debe tener
    $2$ padres distintos (uno de color negro y otro blanco), pero esto
    contradice a la funci\'on de parentezco, que como vimos cuando se
    mostr\'o \textbf{BFS}, a cada v\'ertice le asocia un \'unico padre.
    Por tanto no existe $z \in V_G : z \in X \land z \in Y$ y concluimos
    que $X\cap Y = \emptyset$.
    
  \end{itemize}
  \hfill $\dashv$
\end{enumerate}
\begin{algorithm}[H]
  \SetAlgorithmName{}{}%OddCycleOrBipartition}{}
  \DontPrintSemicolon
  \SetKwData{False}{false}\SetKwData{True}{true}
  \SetKwFunction{New}{new}\SetKwFunction{End}{end}\SetKwFunction{Used}{used}
  \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

  \KwIn{Una gráfica conexa $G$ con un v\'ertice distingido $r$.}
  \KwOut{Una lista que contenga un ciclo impar o un conjunto que
    contenga una bipartici\'on entre los v\'ertices.}
  \BlankLine {
    $Q \gets$ \code{[]}; $i \gets 0$\;
    $L \gets$ \code{[]}; $C \gets \emptyset$\;
    \code{X} $\gets \emptyset$; \code{Y} $\gets \emptyset$\;
    $i \gets i + 1$; \code{X} $\gets r$\;

    colorear a \code{r} de negro\;
    añadir a \code{r} al final de $Q$\;
    $t(r) \gets i, \mathcal{P}(r) \gets \emptyset, \ell(r) \gets 0$\;
    
    \While{$Q \not=$ \textnormal{\code{[]}}}{
      
      elegir a la cabeza $x$ de $Q$\;

      \uIf{\textnormal{$x$ tiene un vecino $y$ sin colorear}}{
        $i \gets i + 1$\;
        \uIf{$x$ es color negro}{
          \code{Y} $\gets y$\;
          colorear a $y$ de blanco\;
        } \Else{
          \code{X} $\gets y$\;
          colorear a $y$ de negro\;
        }
        
        añadir $y$ al final de $Q$\;
        $t(r) \gets i, \mathcal{P}(y) \gets x, \ell(y) \gets \ell(x) + 1$\;
      } \Else{

        \If{\textnormal{$x$ tiene un vecino $y$ coloreado \small{\&}
            \normalsize$\ell(x) = \ell(y)$}}{
          $L \gets$ \code{[x,y,x]}\;
          \code{temp} $\gets$ \code{[]}\;

          \While{$\mathcal{P}(x) \not= \mathcal{P}(y)$}{
            $x \gets \mathcal{P}(x)$; $y \gets \mathcal{P}(y)$\;
            \code{temp} $\gets$ \code{[$x, y$]}\;
            insertar \code{temp} entre la primer $x$ y $y$ en $L$\;
          }
          
          insertar $\mathcal{P}(x)$ entre la primer $x$ y $y$ en $L$\;
          {\Return L\;}
        }
        
        eliminar $x$ de Q\;
      }
    }
    
    $C \gets$ \code{[X, Y]}\;
  } {\Return $C$\;}
  \caption{OddCycleOrBipartition$(<G,r>;L/C)$} \label{OddCycleOrBipartition}
  \DecMargin{1em}
\end{algorithm}
\textbf{Prop. 2:} [Invariante de ciclo, en caso de haber ciclo impar]. La lista
devuelta por el algoritmo \code{OddCycleOrBipartition}, cuando $G$
no es bipartita, es un ciclo impar.

\textbf{Dem.} Por el teorema anunciado con anterioridad (mostrado en clase), tenemos
que nuestra gr\'afica no es bipartita.

Obs\'ervese que por la l\'inea $22$ tenemos un ciclo, pues estamos antes $x,y \in V_G$
que ya han sido explorados con anterioridad, sin embargo existe una $xy$-arista, por
tanto hay dos trayectorias con alg\'un v\'ertice en com\'un (\textit{e.g.}, $r$) que terminan
en $x$ e $y$ respectivamente, luego la $xy$-arista cierra un ciclo. De esta manera s\'olo
nos falta verificar que el ciclo es de longitud impar, para esto veamos que, como $x$ tiene
el mismo nivel que $y$, entonces para el ancestro com\'un a $x$ e $y$ m\'as lejano de $r$,
llamemosle $z \in V_G$, tenemos que $d(z,x) = d(z,y)$, esto se sigue de
\begin{eqnarray*}
  d(z,x) &=& \ell(x) - \ell(z)\\
  &=& \ell(y) - \ell(z)\\
  &=& d(z,y)
\end{eqnarray*}
as\'i, $[d(z,x) + d(z,y)] \stackrel{2}{\equiv}0$, y si ha esto le sumamos la $xy$-arista,
entonces tenemos que
\[
[d(z,x) + d(z,y) + |xy|] \stackrel{2}{\equiv}1
\]
de lo anterior, hemos encontrado un ciclo impar. El ciclo \underline{While} de la $25$
termina cuando se llega a un ancestro en com\'un, que en el peor de los casos este ser\'ia
$r$, as\'i la l\'inea $28$ inserta listas binarias al centro de $L$ y permite tener consistencia
con el orden del ciclo, finalmente la l\'inea $30$ inserta al ancestro, de $x$ e $y$, com\'un
m\'as lejano de $r$ a la lista $L$. Por tanto, con $L$ se puede construir un ciclo de
longitud impar.
\hfill $\dashv$

\hfill $\square$
\newpage
\begin{enumerate}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 03
\item[$3$.] Describa un algoritmo basado en BFS para encontrar el ciclo impar m\'as
  corto en una gr\'afica.
  \end{enumerate}
\begin{algorithm}[H]
  \SetAlgorithmName{}{}%OptimalOddCycle}{}
  \DontPrintSemicolon
  \SetKwData{False}{false}\SetKwData{True}{true}
  \SetKwFunction{New}{new}\SetKwFunction{End}{end}\SetKwFunction{Used}{used}
  \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

  \KwIn{Una gráfica conexa $G$, que contenga al menos un ciclo impar, con un v\'ertice distingido $r$.}
  \KwOut{Una lista que contenga al ciclo impar m\'as corto.}
  \BlankLine {
    $Q \gets$ \code{[]}; $i \gets 0$\;
    $L_1, L_2 \gets$ \code{[]}\;
    $i \gets i + 1$\;

    colorear a \code{r} de negro\;
    añadir a \code{r} al final de $Q$\;
    $t(r) \gets i, \mathcal{P}(r) \gets \emptyset, \ell(r) \gets 0$\;
    
    \While{$Q \not=$ \textnormal{\code{[]}}}{
        \uIf{\textnormal{$x$ tiene un vecino $y$ sin colorear}}{
          $i \gets i + 1$\;
          elegir a la cabeza $x$ de $Q$\;
          colorear a $y$ de negro\;
          añadir $y$ al final de $Q$\;
          $t(r) \gets i, \mathcal{P}(y) \gets x, \ell(y) \gets \ell(x) + 1$\;
        } \Else{
          
          \If{\textnormal{$x$ tiene un vecino $y$ coloreado \small{\&}
              \normalsize$\ell(x) = \ell(y)$}}{
            $L_1 \gets$ \code{[x,y,x]}\;
            \code{temp} $\gets$ \code{[]}\;
            
            \While{$\mathcal{P}(x) \not= \mathcal{P}(y)$}{
              $x \gets \mathcal{P}(x)$; $y \gets \mathcal{P}(y)$\;
              \code{temp} $\gets$ \code{[$x, y$]}\;
              insertar \code{temp} entre la primer $x$ y $y$ en $L_1$\;
            }
            
            insertar $\mathcal{P}(x)$ entre la primer $x$ y $y$ en $L_1$\;
            %%{\Return $L_1$\;}
            \uIf{\textnormal{$|L_2| =$ \code{[]}}}{
              $L_2 \gets L_1$\;
            } \ElseIf{$|L_1|<|L_2|$}{
              $L_2 \gets L_1$\;
            }
          }
          
          eliminar $x$ de Q\;
        }
    }
    
  } {\Return $L_2$\;}
  \caption{OptimalOddCycle$(<G,r>;L/C)$} \label{OptimalOddCycle}
  \DecMargin{1em}
\end{algorithm}
\hfill $\square$
\begin{enumerate}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 04
\item[$4$.] Sea $G$ una gr\'afica con conjunto de bloques $B$ y conjunto de
  v\'ertices de corte $C$.   La {\em gr\'afica de bloques y cortes} de $G$,
  denotada por $B_C (G)$, esta definida por $V_{B_C (G)} = B \cup C$ y
  si $u, v \in V_{B_C (G)}$, entonces $uv \in E_{B_C (G)}$ si y s\'olo si
  $u \in B$, $v \in C$ y $v$ es un v\'ertice de $u$.   Demuestre que
  $B_C (G)$ es un \'arbol.
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 05
\item[$5$.] Describa un algoritmo para encontrar un bosque generador en una
  gr\'afica arbitraria (no necesariamente conexa).
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 06
\item[$6$.] Una {\em gr\'afica de Moore de di\'ametro $d$} es una gr\'afica
  regular de di\'ametro $d$ y cuello $2d+1$.   Demuestre que si $G$ es
  una gr\'afica de Moore, entonces todos los \'arboles de BFS de $G$
  son isomorfos.

\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EXTRAS
\section*{Puntos Extra}
\begin{enumerate}
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extra 01
\item Sea $G$ una gr\'afica conexa en la que todo \'arbol de DFS es una
  trayectoria hamiltoniana (con la ra\'iz en uno de los extremos).   Demuestre
  que $G$ es un ciclo, una gr\'afica completa, o una gr\'afica bipartita completa
  en la que ambas partes tienen el mismo n\'umero de v\'ertices.
  
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extra 02
\item Modifique BFS para que sea recursivo en lugar de iterativo.
  
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extra 03
\item Modifique DFS para que sea recursivo en lugar de iterativo.
  
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extra 04
\item Modifique al algoritmo BFS para que:
  \begin{enumerate}
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ inciso (a)
  \item Reciba una gr\'afica no necesariamente conexa con dos
    v\'ertices distinguidos $r$ y $t$.
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ inciso (b)
  \item El algoritmo empiece en $r$, y termine cuando encuentre al
    v\'ertice $t$, en cuyo caso lo regresa, junto con una trayectoria de
    longitud m\'inima de $r$ a $t$, o cuando decida que el v\'ertice $t$
    no puede ser alcanzado desde $r$, en cuyo caso regresa el valor
    \texttt{false}.
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ inciso (c)
  \item El primer paso dentro del loop de \texttt{while} sea {\bf eliminar} la
    cabeza de la cola.
  \end{enumerate}

\end{enumerate}
\end{document}
