\documentclass{article}

% Symbols
\usepackage{amsfonts, amsthm}
\usepackage{upgreek}
\usepackage{physics}
\usepackage{cancel}
\usepackage{amssymb, latexsym, amsmath}

%Algorithms
\usepackage[ruled,lined,linesnumbered,commentsnumbered]{algorithm2e}

%% Identación
\setlength{\parindent}{0cm}

% Código
\newcommand{\code}[1]{\textcolor{white!25!black}{\texttt{#1}}}
\usepackage{listings}

%AMS
\usepackage{amsthm}
\newtheorem{algo-thm}{Algoritmo}

% Proof
\renewcommand*{\proofname}{\textbf{Demostraci\'on:}}
% Theorem
\newtheorem*{theorem}{Teorema}

% Graphics
\usepackage{graphicx}
\usepackage{pgf}

% Color a letras.
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Tikz
\usepackage{tkz-graph}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
%\usetikzlibrary[topaths]

% Def. Dr. César.
\usetikzlibrary{shapes,calc}
\tikzstyle{edge}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.1pt]
\tikzstyle{blueE}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.5pt, blue]
\tikzstyle{blackV}=[circle, fill=black, minimum size=6pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{blueV}=[circle, fill=blue, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redV}=[circle, fill=red, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redSV}=[semicircle, fill=red, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blueSV}=[semicircle, fill=blue, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blackSV}=[semicircle, fill=black, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{vertex}=[circle, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]

% Margins
\addtolength{\voffset}{-1.5cm}
\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\textheight}{3cm}

%Header-Footer
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{1pt}

\newcommand{\set}[1]{
  \left\{ #1 \right\}
}

%\pagenumbering{gobble} -- Este comando
%                       -- quita el número de página.
\footskip = 50pt
\renewcommand{\headrulewidth}{1pt}

\pagestyle{fancyplain}

\begin{document}
\title{UNIVERSIDAD AUT\'ONOMA DE M\'EXICO\\ Facultad de Ciencias}
\author{Autores:
  \\ Fernanda Villaf\'an Flores
  \\ Fernando Alvarado Palacios
  \\ Adri\'an Aguilera Moreno}
\date{}
\maketitle
\begin{center}
  \includegraphics[scale=0.20]{../Imagen/Portada.jpg}\\[0.4cm]
  \Large
  \bf{Gr\'aficas y Juegos}
  \normalsize
\end{center}
\newpage
\fancyhead[r]{ Gr\'aficas y Juegos 2022-1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\LARGE{Tarea 9 y 10}}
\section*{Puntos Extra}
\begin{enumerate}
\item (2 puntos) Sea $G$ una gr\'afica conexa y $e$ una arista de $G$ que
  no sea un lazo. Exhiba una biyecci\'on entre el conjunto de \'arboles
  generadores de $G$ que contienen a $e$ y el conjunto de \'arboles
  generadores de $G / e$.


  \begin{proof} 

    Sea G un conjuntos de arbloes generadores y T$\subset$G tal que e$\in$T y T'$\subset$G tal que T'=G$\setminus$e.
    
    Definamos la funcion f: T$\rightarrow$T' tal que si g$\in$T  $\Longrightarrow$ f(g)=g$\setminus$e.
    
    
    Observemos que como g$\in$T (g es un arbol generador) $\Longrightarrow$ f(g) tambien será un arbol generador $\Longrightarrow$ la función f preseva conexidad.
    
    Pd) f es inyectiva 
    
    Sea $g_1$, $g_2 \Longrightarrow$ si f($g_1$)=f($g_2$) $\Longrightarrow$ el subconjunto A y A' de aristas en G que induce a f($g_1$) y f($g_2$) respectivamente son iguales $\Longrightarrow g_1=A\setminus e=A'\setminus e=g_2 \Longrightarrow g_1=g_2$.
    
    Por lo tanto f es inyectiva
    
    Pd) f es suprayectiva
    
    Sea b$\in$T' $\Longrightarrow$ por definicion b=b$\setminus$e $\Longrightarrow$ sea w un vértice que une a las aristas $a_1$ y $a_2 \Longrightarrow$ "Partimos a w en dos vértices u,v" y en medio de u y v colocamos a e y denostamos a este nuevo árbol como $g_3 \Longrightarrow$ existe $g_3 \in T$ tal que f($g_3$)=b.
    
    Por lo tanto f es sobreyectiva.
    
    Por lo tanto f es un biyección.
    
    \end{proof}

\item (2 puntos) Sea $T$ un \'arbol de DFS de una gr\'afica conexa no
  trivial $G$, y sea $v$ la raiz de un bloque $B$ de $G$.   Demuestre
  que el grado de $v$ en $T \cap B$ es uno.


  \begin{proof} 
    Observemos el caso particualar para $k_2$, este caso siempre se cumple sin importar en que vértice se jecute DFS, nuestro árbol siempre será de tipo $k_2$, donde los dos vértices tendran grado 1.
    
    Sea G  una gráfica conexa con al menos 3 vértices y v$\in$V $\Longrightarrow$ ejecutando DFS en v y s.p.g supongamos v es la raiz de algun bloque T de G. $\Longrightarrow$ si w es el primer vecino del mismo bloque de $v$ que visitamos.
    
    Sabemos que dado $3$ $x, y, z$ vértices en un bloque, entonces existe una trayectoria $T_{\alpha}$ que une a
    $x, y$ (S.P.G.) además $T_{\alpha}$ no pasa por $z$, por tanto el siguiente vértice que visitemos
    después de $w$ no saldrá de $v$. Además DFS ya no agrega a la pila los vértices previamente visitados. Así, en
    el árbol DFS de $G$, $G \cap T$ sólo tendrá los vértices de $T$ y ahí la raíz tendrá $d(v)=1$.
    
    \end{proof}


\item (2 puntos)  Si $f$ es la funci\'on de tiempo de entrada del
  algoritmo DFS, defina $f^\ast\colon V \to \mathbb{N}$ de la siguiente
  forma.   Si alg\'un ancestro propio de $v$ puede ser alcanzado desde
  $v$ mediante una trayectoria dirigida que consista de flechas del
  \'arbol (posiblemente ninguna) seguida de una flecha que no est\'a en
  el \'arbol (que va hacia arriba), $f^\ast (v)$ se define como el menor
  valor de $f$ de un ancestro de este tipo; si no, $f^\ast (v) = f(v)$.
  Observe que un v\'ertice $v$ es la ra\'iz de un bloque si y s\'olo si
  tiene un hijo $w$ tal que $f^\ast (w) \ge f(v)$.   Modifique el algoritmo
  DFS para que regrese los v\'ertices de corte y los bloques de una
  gr\'afica conexa.
  
  Primero describiremos un algoritmo que encuentra los vértices de corte de una gráfica.\\
  
  \begin{algorithm}[H]
    \textbf{Input: }Una gráfica $G$, un vértice distinguido $r$ y el tiempo
    $t$ de entrada de vértice en cuestión. \\
    \textbf{Output: }Una colección $C$ con los vértices de corte.\\
    $i \leftarrow t$;\\
    $i \leftarrow i+1$;\\
    $C \leftarrow []$;\\
    $f(r) \leftarrow i$, $f^{*}(r) \leftarrow f(r)$\\
    \While{$r$ \textnormal{tenga vecinos}}{
      Sea $v$ un vecino de $r$.\\
      \If{$v$ \textnormal{no está visitado}}{
        $p(v) \leftarrow r$\\
        $C \leftarrow$ DFS-CutVertex($G$, $v$, $i$);\\
        \If{$r$ \textnormal{no tiene padre, y tiene mas de dos hijos}}{
          añadir $r$ a la colección $C$;\\
        }\Else{
          $f^{*}(r) \leftarrow min(f^*(r), f^*(v));$\\
          \If{$f^*(v) \geq f(r)$}{
            añadir $r$ a la colección $C$.\\
          }
        }
      }\ElseIf{$v$ \textnormal{no es el padre de} $r$ y $f(v) \textless f(r)$}{
        $f^*(r) \leftarrow min(f^*(r), f(v))$\\
      }
    }
    $i \leftarrow i+1$;\\
    $l(r) \leftarrow i$;\\
    \Return $C$;
    \caption{DFS-CutVertex}
  \end{algorithm}
  
  %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%
  
  Nótese que el tiempo $t$ en la primer ejecución es igual a 0, como el código
  es recursivo, eventualmente nos servirá introducir un nuevo tiempo que corresponda a la entrada del vértice en cuestión a la pila. Una vez teniendo el algoritmo para obtener los vértices de corte de una gráfica, podemos usarlo en un nuevo algoritmo para encontrar tanto los vértices de corte, junto con los bloques en una gráfica $G$ conexa.\\
  
  %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%
  
  \begin{algorithm}[H]
    \textbf{Input:} Una gráfica $G$, un vértice distinguido $r$ y el tiempo
    $t$ de entrada de vértice en cuestión. \\
    \textbf{Output:} Una colección $C$ de vértices de corte y un conjunto $B$ de bloques de la gráfica $G$.\\
    S $\leftarrow$ []; i $\leftarrow t$;\\
    i $\leftarrow$ i + 1;\\
    $C \leftarrow []$; $B \leftarrow \emptyset$;\\
    marcar a $r$ como visitado.\\
    $f(r) \leftarrow i$, $f^{*}(r) \leftarrow f(r)$;\\
    
    \While{$r$ \textnormal{tenga vecinos}}{
      Sea $v$ un vecino de $r$.\\
      \If{$v$ \textnormal{no ha sido visitado}}{
        $p(v) \leftarrow r$;\\
        metemos a la arista $(r,v)$ a $S$ en el tope;\\
        $C \leftarrow$ DFS-CutVertex($G$, $v$, $i$);\\
        $f^*(r) \leftarrow min(f^*(r), f^*(v))$;\\
        \If{$f^*(v) \geq f(u)$}{
          Sacamos el tope de la pila y lo insertamos en $S$, tantas veces
          hasta que saquemos a $(u,v)$ y estás serán las aristas de una 
          componente $b$ y añadimos $b$ a $B$.\\
        }
      }\ElseIf{$v$ \textnormal{no es el padre de} $r$ y $f(v) \textless f(r)$}{
        Metemos a la arista $(r,v)$ en $S$;\\
        $f^*(r) \leftarrow min(f^*(r), f(v))$;\\
      }
    }
    $i \leftarrow i+1$;\\
    $l(r) \leftarrow i$;\\
    \Return C, B;
    \caption{DFS-CutVertexBlock.}
  \end{algorithm}
  
  Así obtenemos los vértices de corte y los bloques de una gráfica $G$ conexa.\\
  
\item (2 puntos) Sea $T$ un \'arbol \'optimo en una gr\'afica conexa
  ponderada $(G,w)$ (con pesos positivos), y sean $x$ y $y$ v\'ertices
  adyacentes en $T$. Demuestre que la trayectoria $xTy = xy$ es una
  $xy$-trayectoria de peso m\'inimo en $G$.
  
  \begin{proof} 
    (Demostración por reduccion al absurdo)
    
    Sea (G,w) una gráfica conexa ponderada, T un árbol optimo y x,y $\in$V(G,W),
    supongamos que xTy no es una trayectoria optima en (G,w) $\Longrightarrow$
    Existe $t_0$ tal que  $t_0$ sea un árbol generador, $t_0$ sea diferente a
    T $\Longrightarrow$ y la trayectoria optima sea x$t_0$y $\Longrightarrow t_0$
    tiene mayor peso que T, ya que la trayectoria xTy es mas pesada
    $\Longrightarrow$ que T no es un arbol optimo (Lo que es una contradiccion
    a nuestra hipotesis).
    
    
    Por lo tanto xTy es una trayectoria optima.
    
    
  \end{proof}

  
\item (2 puntos) Demuestre que si todos los pesos de una gr\'afica
  ponderada $G$ son distintos, entonces $G$ tiene un \'unico \'arbol
  \'optimo.

  \begin{proof}
    Supongamos a G una gráfica ponderada con el costo de sus aristas
    distintos entre si, sean $T_1$ y $T_2$ arboles tales que 
    \[
    T_1 \neq  T_2 
    \]
    y ambos son arboles óptimos en G (P.D., la unicidad de $T_1$),
    entonces consideremos a $e$ una arista de peso mínimo que está
    contenida en  $T_1$ o $T_2$ (esto por que las aristas tienen
    pesos distintos entonces solo habrá una con peso mínimo),
    llamémosla $e_1$, luego s.p.g. que $e_1$ está contenida en $T_1$.
    \[
    \Rightarrow e_1 \notin T_2
    \]
    por lo que si unimos  $e_1 + T_2$ es claro que existirá al menos
    un ciclo C el cual contendrá al menos una arista digamos $e_2$
    que no está contenida en $T_1$ (Esto por que si lo estuviera,
    entonces $T_1$ formaría un ciclo con $e_2$, pero  $T_1$ es un árbol).\\
    Entonces llegamos a que $e_1$ y $e_2$ contenidas en $T_1$ o $T_2$ por
    construcción de las mismas tenemos que 
    \[
    w(e_1) < w(e_2)
    \]
    luego podemos notar que se si
    \[
    (T_2 \cup e_1) - e_2
    \]
    es claro que genera la construcción de $T_1$   por la construcción
    de  $T_1$  y $T_2$  implica que 
    \[
    W(T_1) < W(T_2)!!
    \]
    \hspace*{4cm} $\therefore\ \ \  G$ es un árbol óptimo único.
  \end{proof}


\item (2 puntos) Modifique el algoritmo de Bor\r uvka-Kruskal para que en cada
  iteraci\'on v\'ertices en la misma componente del bosque $F$ reciban el
  mismo color y v\'ertices en componentes distintas reciban colores distintos.
  
  A continuación se muestra la modificación del algoritmo de Bor\r uvka-Kruskal:
  
  \begin{algorithm}[H]
    \SetAlgoNoLined
    \caption{Bor\r uvka-Kruskal-Coloration}
    \textbf{Input:} $G$ una gráfica ponderada\\
    \textbf{Output:} Un bosque óptimo $B = (F,V)$ de $G$ donde cada árbol tiene una coloración distinta.\\
    1. $F \leftarrow \emptyset$, $w(B) \leftarrow \emptyset$, $i \leftarrow 0$;\\
    2. \For{$v \in V_G$}{
      3. asignarle $i++$ como color a $v$.
    } 
    4. \While{\textnormal{exista una arista} $e \in E-F$ \textnormal{tal que} $F \cup \{e\}$ \textnormal{induce a un bosque}}{5. Elegir $e$ de peso mínimo con dicha característica\\
      6. \If{\textnormal{los extremos de $e$ tienen colores diferentes}}{7. Asignamos como el color de ambas, al color mas mínimo entre las dos.\\
        8. F\leftarrow $F \cup \{e\}$, $w(B)\leftarrow w(B)+w(e)$}.}
    \Return $(F,w(T));$
  \end{algorithm}
  
\item (2 puntos) Demuestre que el problema de encontrar un \'arbol generador
  de peso m\'aximo en una gr\'afica conexa puede resolverse eligiendo
  iterativamente una arista de peso m\'aximo, con la condici\'on de que la
  subgr\'afica resultante siga siendo un bosque. (Proponga un algoritmo y
  demuestre que es correcto.)

\item (2 puntos) Escriba una versi\'on del algoritmo BFS para digr\'aficas.
  Utilice esta versi\'on de BFS dirigida para describir un algoritmo que
  encuentre un ciclo dirigido de longitud m\'inima en una digr\'afica.    Su
  versi\'on dirigida de BFS debe de correr en tiempo $\mathcal{O} (|V| +
  |E|)$, y el algoritmo para encontrar el ciclo dirigido m\'as corto debe
  correr en tiempo a lo m\'as $\mathcal{O} (|V|^2 + |V| |E|)$.
\end{enumerate}

\end{document}
